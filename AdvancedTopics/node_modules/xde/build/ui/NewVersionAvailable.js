'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _desc, _value, _class;

var _aphrodite = require('aphrodite');

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _autobindDecorator = require('autobind-decorator');

var _autobindDecorator2 = _interopRequireDefault(_autobindDecorator);

var _electron = require('electron');

var _os = require('os');

var _os2 = _interopRequireDefault(_os);

var _Notification = require('./Notification');

var _Notification2 = _interopRequireDefault(_Notification);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

const app = _electron.remote.app;
const autoUpdater = _electron.remote.autoUpdater;


const NOTIFICATION_TIMEOUT_MS = 5000;

let NewVersionAvailable = (_class = class NewVersionAvailable extends _react2.default.Component {
  constructor(props, context) {
    super(props, context);
    this.state = {
      isVisible: false,
      isChecking: false,
      isDownloading: false,
      errorMessage: null,
      newVersion: null,
      quitAndUpdate: null
    };
  }

  render() {
    // N.B. If you are working on the UI for XDE updates, change this to `true` or else
    // that UI will never show up when running `npm start`
    let WORKING_ON_XDE_UPDATES = false;
    let AUTO_UPDATES_SUPPORTED = process.platform !== 'linux';

    // Should we use NODE_ENV instead of XDE_NPM_START?
    if (!this.state.isVisible || !WORKING_ON_XDE_UPDATES && process.env.XDE_NPM_START || !AUTO_UPDATES_SUPPORTED) {
      return _react2.default.createElement('div', { className: (0, _aphrodite.css)(styles.hidden) });
    }

    var _state = this.state;
    let isChecking = _state.isChecking;
    let isDownloading = _state.isDownloading;
    let errorMessage = _state.errorMessage;
    let newVersion = _state.newVersion;

    let text;
    let clickListener;
    let buttonStyle = 'info';
    if (errorMessage != null) {
      text = `An error occurred while checking for a new version of XDE: ${ errorMessage }. Click to retry.`;
      clickListener = this._checkForUpdate;
      buttonStyle = 'danger';
    } else if (newVersion != null) {
      text = `A new version of XDE is available. Click to restart and install XDE ${ newVersion }.`;
      clickListener = this._quitAndUpdate;
    } else if (isDownloading) {
      text = 'A new version of XDE is available. You can keep working while it is downloading.';
    } else if (isChecking) {
      text = 'Checking if there is a new version of XDE...';
    } else {
      text = 'Click to check for a new version of XDE.';
      clickListener = this._checkForUpdate;
    }

    return _react2.default.createElement(_Notification2.default, {
      onClick: clickListener,
      type: buttonStyle === 'danger' ? 'error' : 'success',
      message: text
    });
  }

  componentDidMount() {
    autoUpdater.on('error', this._handleUpdateError);
    autoUpdater.on('checking-for-update', this._handleCheckingForUpdate);
    autoUpdater.on('update-available', this._handleUpdateAvailable);
    autoUpdater.on('update-not-available', this._handleUpdateNotAvailable);
    autoUpdater.on('update-downloaded', this._handleUpdateDownloaded);

    let version = app.getVersion();
    autoUpdater.setFeedURL(`https://xde-updates.exponentjs.com/update/${ _os2.default.platform() }_${ _os2.default.arch() }/${ version }`);
    this._checkForUpdate();
  }

  componentWillUnmount() {
    // We need to call removeAllListeners instead of removeListener because
    // the latter doesn't work over Electron's IPC channel
    autoUpdater.removeAllListeners('error');
    autoUpdater.removeAllListeners('checking-for-update');
    autoUpdater.removeAllListeners('update-available');
    autoUpdater.removeAllListeners('update-not-available');
    autoUpdater.removeAllListeners('update-downloaded');
  }

  _checkForUpdate() {
    autoUpdater.checkForUpdates();
  }

  _quitAndUpdate() {
    if (this.state.quitAndUpdate) {
      this.state.quitAndUpdate();
    } else {
      console.error('Do not have a function to quit and update XDE');
    }
  }

  _handleUpdateError(event, message) {
    this.setState({
      isVisible: true,
      errorMessage: message,
      // Not strictly true that an error means we've stopped checking for
      // updates or downloading. It depends on the error.
      isChecking: false,
      isDownloading: false
    });

    setTimeout(() => {
      this.setState({ isVisible: false });
    }, NOTIFICATION_TIMEOUT_MS);
  }

  _handleCheckingForUpdate() {
    this.setState({
      isChecking: true,
      isDownloading: false,
      errorMessage: null
    });
  }

  _handleUpdateAvailable() {
    this.setState({
      isChecking: false,
      isDownloading: true,
      errorMessage: null
    });
  }

  _handleUpdateNotAvailable() {
    this.setState({
      isChecking: false,
      isDownloading: false,
      errorMessage: null
    });
  }

  _handleUpdateDownloaded(event, releaseNotes, releaseName, releaseDate, updateUrl, quitAndUpdate) {
    this.setState({
      isVisible: true,
      isChecking: false,
      isDownloading: false,
      errorMessage: null,
      newVersion: releaseName,
      quitAndUpdate
    });
  }
}, (_applyDecoratedDescriptor(_class.prototype, '_checkForUpdate', [_autobindDecorator2.default], (0, _getOwnPropertyDescriptor2.default)(_class.prototype, '_checkForUpdate'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, '_quitAndUpdate', [_autobindDecorator2.default], (0, _getOwnPropertyDescriptor2.default)(_class.prototype, '_quitAndUpdate'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, '_handleUpdateError', [_autobindDecorator2.default], (0, _getOwnPropertyDescriptor2.default)(_class.prototype, '_handleUpdateError'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, '_handleCheckingForUpdate', [_autobindDecorator2.default], (0, _getOwnPropertyDescriptor2.default)(_class.prototype, '_handleCheckingForUpdate'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, '_handleUpdateAvailable', [_autobindDecorator2.default], (0, _getOwnPropertyDescriptor2.default)(_class.prototype, '_handleUpdateAvailable'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, '_handleUpdateNotAvailable', [_autobindDecorator2.default], (0, _getOwnPropertyDescriptor2.default)(_class.prototype, '_handleUpdateNotAvailable'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, '_handleUpdateDownloaded', [_autobindDecorator2.default], (0, _getOwnPropertyDescriptor2.default)(_class.prototype, '_handleUpdateDownloaded'), _class.prototype)), _class);
exports.default = NewVersionAvailable;


let styles = _aphrodite.StyleSheet.create({
  hidden: {
    display: 'none'
  }
});
//# sourceMappingURL=../__sourcemaps__/ui/NewVersionAvailable.js.map
