'use strict';

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _xdl = require('xdl');

var _noImportant = require('aphrodite/no-important');

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _bunyan = require('bunyan');

var _bunyan2 = _interopRequireDefault(_bunyan);

var _electron = require('electron');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _jsonFile = require('@exponent/json-file');

var _jsonFile2 = _interopRequireDefault(_jsonFile);

var _Constants = require('./Constants');

var _Commands = require('./Commands');

var _Commands2 = _interopRequireDefault(_Commands);

var _ConsoleLog = require('./ConsoleLog');

var _ConsoleLog2 = _interopRequireDefault(_ConsoleLog);

var _LoginPage = require('./LoginPage');

var _LoginPage2 = _interopRequireDefault(_LoginPage);

var _NewProjectModal = require('./NewProjectModal');

var _NewProjectModal2 = _interopRequireDefault(_NewProjectModal);

var _NewVersionAvailable = require('./NewVersionAvailable');

var _NewVersionAvailable2 = _interopRequireDefault(_NewVersionAvailable);

var _Notification = require('./Notification');

var _Notification2 = _interopRequireDefault(_Notification);

var _ProjectList = require('./ProjectList');

var _ProjectList2 = _interopRequireDefault(_ProjectList);

var _StyleConstants = require('./StyleConstants');

var _StyleConstants2 = _interopRequireDefault(_StyleConstants);

var _Styles = require('./Styles');

var _Styles2 = _interopRequireDefault(_Styles);

var _MenuItem = require('./toolbar/MenuItem');

var _MenuItem2 = _interopRequireDefault(_MenuItem);

var _Popover = require('./toolbar/Popover');

var _Popover2 = _interopRequireDefault(_Popover);

var _ToolBar = require('./toolbar/ToolBar');

var _ToolBar2 = _interopRequireDefault(_ToolBar);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_xdl.Config.developerTool = 'xde';

const NOTIFICATION_TIMEOUT_MS = 5000;
const OPTIONS_ICON_SIZE = 22;
const DEVICES_ICON_SIZE = 16;
const PROJECT_OPENED_MESSAGE = 'Project opened! You can now use the "Send Link" or "Device" buttons to view your project.';

const TAB_LEFT_VISIBLE = 'tab-left-visible',
      TAB_RIGHT_VISIBLE = 'tab-right-visible',
      TAB_BOTH_VISIBLE = 'tab-both-visible';

let App = class App extends _react2.default.Component {

  constructor(props, context) {
    var _this;

    _this = super(props, context);

    this._toggleDeviceLogsPopover = event => {
      event.stopPropagation();
      if (this.state.focusedConnectedDeviceId) {
        this._onTogglePopover(_Constants.PopoverEnum.DEVICE_LOGS);
      }
    };

    this._setSelectedDevice = deviceId => {
      this.setState({
        focusedConnectedDeviceId: deviceId
      });
    };

    this._defaultDeviceLogs = () => {
      let logs = [{
        level: _bunyan2.default.INFO,
        msg: `Logs from devices will appear here`,
        time: this._startTime
      }];

      if (this.state.exponentSdkStatus === _xdl.Doctor.EXPONENT_SDK_NOT_INSTALLED) {
        logs.push({
          level: _bunyan2.default.WARN,
          msg: `Please run \`npm install --save exponent\` and add \`import 'exponent'\` to the top of your main file to see device logs.`,
          time: this._startTime
        });
      } else if (this.state.exponentSdkStatus === _xdl.Doctor.EXPONENT_SDK_NOT_IMPORTED) {
        logs.push({
          level: _bunyan2.default.WARN,
          msg: `Add \`import 'exponent'\` to the top of your main file to see device logs.`,
          time: this._startTime
        });
      } else if (this.state.isProjectRunning && !(this.state.expJson && _xdl.Versions.gteSdkVersion(this.state.expJson, '7.0.0'))) {
        logs.push({
          level: _bunyan2.default.WARN,
          msg: `To see device logs, make sure your project uses at least SDK 7.0.0 and has a valid exp.json.`,
          time: this._startTime
        });
      }

      return logs;
    };

    this._renderDeviceLogs = () => {
      var _state = this.state;
      let connectedDevices = _state.connectedDevices;
      let focusedConnectedDeviceId = _state.focusedConnectedDeviceId;


      let device = focusedConnectedDeviceId ? connectedDevices[focusedConnectedDeviceId] : null;
      let bottomBarRightContent = this.state.tabsVisible !== TAB_LEFT_VISIBLE ? this._renderTabsVisibleControl() : null;
      let logs = device && device.logs.length ? device.logs : this._defaultDeviceLogs();
      return _react2.default.createElement(
        'div',
        { className: (0, _noImportant.css)(styles.tabContainer) },
        _react2.default.createElement(_ConsoleLog2.default, {
          logs: logs,
          bottomBarLeftContent: this._renderDeviceSwitcher(device),
          bottomBarRightContent: bottomBarRightContent,
          onClickClearLogs: this._onClickClearDeviceLogs
        })
      );
    };

    this._renderDeviceSwitcher = device => {
      return _react2.default.createElement(
        'div',
        null,
        _react2.default.createElement(
          _Popover2.default,
          { body: this._renderPopoverDeviceLogs(), arrowOffset: 16, isAbove: true },
          _react2.default.createElement('img', {
            src: './SelectUpDown.png',
            className: (0, _noImportant.css)(styles.iconWithMargin, styles.deviceSelectIcon),
            onClick: this._toggleDeviceLogsPopover
          })
        ),
        _react2.default.createElement(
          'span',
          { className: (0, _noImportant.css)(styles.deviceSelectText) },
          device ? device.name : 'No devices connected'
        )
      );
    };

    this._renderTabsVisibleControl = () => {
      let tabLeftImage = this.state.tabsVisible !== TAB_RIGHT_VISIBLE ? './IconPanelLeftSelected.png' : './IconPanelLeft.png';
      let tabRightImage = this.state.tabsVisible !== TAB_LEFT_VISIBLE ? './IconPanelRightSelected.png' : './IconPanelRight.png';
      return _react2.default.createElement(
        'div',
        { className: (0, _noImportant.css)(styles.tabsVisibleControl) },
        _react2.default.createElement(
          'a',
          {
            onClick: this._onClickTabLeftVisible },
          _react2.default.createElement('img', {
            src: tabLeftImage,
            className: (0, _noImportant.css)(styles.iconWithMargin, styles.tabVisibleIcon),
            style: { flex: 1 }
          })
        ),
        _react2.default.createElement(
          'a',
          {
            onClick: this._onClickTabRightVisible },
          _react2.default.createElement('img', {
            src: tabRightImage,
            className: (0, _noImportant.css)(styles.iconWithMargin, styles.tabVisibleIcon),
            style: { flex: 1 }
          })
        )
      );
    };

    this._onClickTabLeftVisible = () => {
      let tabsVisible = this.state.tabsVisible === TAB_RIGHT_VISIBLE ? TAB_BOTH_VISIBLE : TAB_RIGHT_VISIBLE;
      this.setState({ tabsVisible });
    };

    this._onClickTabRightVisible = () => {
      let tabsVisible = this.state.tabsVisible === TAB_LEFT_VISIBLE ? TAB_BOTH_VISIBLE : TAB_LEFT_VISIBLE;
      this.setState({ tabsVisible });
    };

    this._runProject = project => {
      this._startProjectAsync(project.root).catch(error => {
        this._logError(`Couldn't open Exp ${ project.name }: ${ error.toString() }`);
      });
    };

    this._onTogglePopover = popover => {
      const isAlreadyOpen = this.state.openPopover === popover;
      this.setState({ openPopover: isAlreadyOpen ? null : popover });

      if (!isAlreadyOpen) {
        _xdl.Analytics.logEvent('Open Popover', {
          popover
        });
      }
    };

    this._closePopover = () => {
      this.setState({ openPopover: null });
    };

    this._urlInputSelect = () => {
      this._urlInput.select();
    };

    this._urlInputCopy = () => {
      this._urlInputSelect();
      document.execCommand('copy');
    };

    this._toggleOptionsPopover = event => {
      event.stopPropagation();
      this._onTogglePopover(_Constants.PopoverEnum.OPTIONS);
    };

    this._closeModal = () => {
      this.setState({
        openModal: null
      });
    };

    this._logOutAsync = (0, _asyncToGenerator3.default)(function* () {
      _this.setState({ user: null });
      yield _this._stopProjectAsync(_this.state.projectRoot);
      yield _xdl.User.logoutAsync();
    });

    this._docsClicked = () => {
      if (this.state.expJson && this.state.expJson.sdkVersion) {
        require('electron').shell.openExternal(`https://docs.getexponent.com/versions/v${ this.state.expJson.sdkVersion }/`);
      } else {
        require('electron').shell.openExternal('https://docs.getexponent.com/');
      }
    };

    this._joinUsOnSlackClicked = () => {
      require('electron').shell.openExternal('https://slack.exponentjs.com/');
    };

    this._chatWithUsOnIntercomClicked = () => {
      _xdl.Intercom.showNewMessage();
    };

    this._sendDiagnosticsReportClicked = (0, _asyncToGenerator3.default)(function* () {
      _xdl.Logger.notifications.info({ indefinite: true }, 'Generating diagnostics report...');
      let deviceInfo = yield _xdl.Diagnostics.getDeviceInfoAsync({
        uploadLogs: true
      });
      _xdl.Intercom.trackEvent('diagnostics', deviceInfo);
      _xdl.Intercom.showNewMessage(`Please explain what went wrong and we'll look at your diagnostics report: `);
      _xdl.Logger.notifications.info('Uploaded report!');
    });
    this._clearXDECacheClicked = (0, _asyncToGenerator3.default)(function* () {
      yield _xdl.Exp.clearXDLCacheAsync();
    });

    this._setProjectSettingAsync = (() => {
      var _ref4 = (0, _asyncToGenerator3.default)(function* (options) {
        let projectSettings = yield _xdl.ProjectSettings.setAsync(_this.state.projectRoot, options);
        let computedUrl = yield _this._computeUrlAsync(_this.state.projectRoot);
        _this.setState({
          projectSettings,
          computedUrl
        });
      });

      return function (_x) {
        return _ref4.apply(this, arguments);
      };
    })();

    this._publishClickedAsync = (0, _asyncToGenerator3.default)(function* () {
      let confirmBeforePublish = yield _xdl.UserSettings.getAsync('confirmBeforePublish', true);

      if (confirmBeforePublish) {
        let dialog = _electron.remote.dialog;

        // Yes = 0
        // Yes, don't ask again = 1
        // No = 2

        var choice = dialog.showMessageBox(_electron.remote.getCurrentWindow(), {
          type: 'question',
          buttons: ['Yes', `Yes, don't ask again`, 'No'],
          title: 'Confirm',
          message: 'This will make your experience publicly accessible. Continue?'
        });

        if (choice === 1) {
          yield _xdl.UserSettings.mergeAsync({ 'confirmBeforePublish': false });
        } else if (choice === 2) {
          return;
        }
      }

      _this._logInfo("Publishing...");
      try {
        let result = yield _xdl.Project.publishAsync(_this.state.projectRoot);
        _this._logInfo(`Published to ${ result.url }`);

        let notificationMessage = 'Project published successfully.';
        let sendTo = _this.state.sendTo;
        if (sendTo) {
          try {
            yield _xdl.Exp.sendAsync(sendTo, result.url);
            _this._logInfo(`Sent link ${ result.url } to ${ sendTo }.`);
          } catch (err) {
            _this._logError(`Could not send link to ${ sendTo }: ${ err }`);
          }
          notificationMessage = `${ notificationMessage } Sent to ${ sendTo }`;
        }
        _this._showNotification('success', notificationMessage);
      } catch (err) {
        _this._showNotification('error', 'Project failed to publish.');
        _this._logError(`Failed to publish package: ${ err.message }`);
      }
    });
    this._newClickedAsync = (0, _asyncToGenerator3.default)(function* () {
      _xdl.Analytics.logEvent('Click New');

      yield _this._stopProjectAsync(_this.state.projectRoot);

      _this.setState({
        openModal: _Constants.ModalEnum.NEW_PROJECT
      });
    });
    this._openClickedAsync = (0, _asyncToGenerator3.default)(function* () {
      _xdl.Analytics.logEvent('Click Open');

      yield _this._stopProjectAsync(_this.state.projectRoot);

      let root = yield _Commands2.default.openExpAsync();
      if (root) {
        yield _this._startProjectAsync(root);
      }
    });
    this._closeClickedAsync = (0, _asyncToGenerator3.default)(function* () {
      _xdl.Analytics.logEvent('Click Close');

      yield _this._stopProjectAsync(_this.state.projectRoot);
    });

    this._restartClickedAsync = (() => {
      var _ref9 = (0, _asyncToGenerator3.default)(function* () {
        let isShiftSelected = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

        _xdl.Analytics.logEvent('Click Restart');

        let clearCacheByDefault = yield _xdl.UserSettings.getAsync('clearCacheByDefault', true);
        let reset = clearCacheByDefault ? !isShiftSelected : isShiftSelected;

        let shiftMessage = '';
        if (!isShiftSelected) {
          shiftMessage = clearCacheByDefault ? ' (Hold shift while clicking restart to avoid clearing cache)' : ' (Hold shift while clicking restart to clear packager cache)';
        }

        _this._logInfo(`Restarting project${ reset ? ' and clearing packager cache' : '' }${ shiftMessage }.`);
        _this.setState({
          computedUrl: null,
          isProjectRunning: false,
          isLoading: true
        }, (0, _asyncToGenerator3.default)(function* () {
          // TODO: refactor this. can't call _startProjectAsync and _stopProjectAsync
          // because they rely on setState calls that work asynchronously.
          let expJson;
          try {
            expJson = yield _xdl.Project.startAsync(_this.state.projectRoot, { reset });
            _this._logInfo(PROJECT_OPENED_MESSAGE);
          } catch (err) {
            _this._logError(err.message);
          }

          let computedUrl = yield _this._computeUrlAsync(_this.state.projectRoot);
          let exponentSdkStatus = yield _xdl.Doctor.getExponentSdkStatus(_this.state.projectRoot);
          _this.setState({
            computedUrl,
            isProjectRunning: true,
            expJson,
            exponentSdkStatus,
            isLoading: false
          });
        }));
      });

      return function (_x2) {
        return _ref9.apply(this, arguments);
      };
    })();

    this._sendClickedAsync = (() => {
      var _ref11 = (0, _asyncToGenerator3.default)(function* (sendTo) {
        _xdl.Analytics.logEvent('Click Send');

        _this.setState({ sendTo });
        let url_ = _this.state.computedUrl;
        try {
          yield _xdl.Exp.sendAsync(sendTo, url_);
          _this._logInfo(`Sent link ${ url_ } to ${ sendTo }.`);
          _xdl.UserSettings.updateAsync('sendTo', sendTo);
        } catch (err) {
          _this._logError(`Could not send link to ${ sendTo }: ${ err }`);
          _this._logError("If you're trying to SMS a link to a mobile device, make sure you are using the `+` sign and the country code at the beginning of the number.");
        }
      });

      return function (_x4) {
        return _ref11.apply(this, arguments);
      };
    })();

    this._onClickClearDeviceLogs = () => {
      var _state2 = this.state;
      let connectedDevices = _state2.connectedDevices;
      let focusedConnectedDeviceId = _state2.focusedConnectedDeviceId;


      if (focusedConnectedDeviceId && connectedDevices[focusedConnectedDeviceId]) {
        connectedDevices[focusedConnectedDeviceId].logs = [];
      }
    };

    this._onClickClearLogs = () => {
      this.setState({ logs: [] });
    };

    this._appendLogChunk = chunk => {
      if (!chunk.shouldHide) {
        this._logsToAdd.push(chunk);

        requestAnimationFrame(() => {
          if (this._logsToAdd.length === 0) {
            return;
          }

          let logs = this.state.logs.concat(this._logsToAdd);
          this._logsToAdd = [];
          this.setState({
            logs
          });
        });
      }
    };

    this._logInfo = data => _xdl.ProjectUtils.logInfo(this.state.projectRoot, 'exponent', data);

    this._logError = data => _xdl.ProjectUtils.logError(this.state.projectRoot, 'exponent', data);

    this._getDeviceName = (id, name) => {
      if (this._deviceIdToName[id]) {
        return this._deviceIdToName[id];
      }

      if (!_lodash2.default.includes(_lodash2.default.values(this._deviceIdToName), name)) {
        this._deviceIdToName[id] = name;
        return name;
      }

      let number = 1;
      while (_lodash2.default.includes(_lodash2.default.values(this._deviceIdToName), `${ name } - ${ number }`)) {
        number++;
      }

      this._deviceIdToName[id] = `${ name } - ${ number }`;
      return this._deviceIdToName[id];
    };

    this._handleDeviceLogs = chunk => {
      this._deviceLogsToAdd.push(chunk);

      requestAnimationFrame(() => {
        if (this._deviceLogsToAdd.length === 0) {
          return;
        }

        this.setState(state => {
          let connectedDevices = state.connectedDevices;
          let focusedConnectedDeviceId = state.focusedConnectedDeviceId;

          for (let i = 0; i < this._deviceLogsToAdd.length; i++) {
            let chunk = this._deviceLogsToAdd[i];
            if (!connectedDevices[chunk.deviceId]) {
              let name = this._getDeviceName(chunk.deviceId, chunk.deviceName);
              if (!focusedConnectedDeviceId) {
                focusedConnectedDeviceId = chunk.deviceId;
              }
              connectedDevices[chunk.deviceId] = {
                name,
                logs: [{
                  level: _bunyan2.default.INFO,
                  msg: `Streaming logs from ${ name }...`,
                  time: new Date()
                }]
              };
            }

            connectedDevices[chunk.deviceId].logs = connectedDevices[chunk.deviceId].logs.concat([chunk]);
          }
          this._deviceLogsToAdd = [];

          return {
            focusedConnectedDeviceId,
            connectedDevices
          };
        });
      });
    };

    this._startProjectAsync = (() => {
      var _ref12 = (0, _asyncToGenerator3.default)(function* (projectRoot) {
        if (_this.state.projectRoot) {
          return false;
        }

        if (!projectRoot) {
          throw new Error("Could not open project: empty root.");
        }

        let projectSettings = yield _xdl.ProjectSettings.readAsync(projectRoot);
        let xdeProjectId = _this._currentOpenProjectXDEId;

        _xdl.ProjectUtils.attachLoggerStream(projectRoot, {
          stream: {
            write: function write(chunk) {
              if (_this._currentOpenProjectXDEId !== xdeProjectId) {
                return;
              }

              if (chunk.tag === 'device') {
                _this._handleDeviceLogs(chunk);
              } else {
                _this._appendLogChunk(chunk);
              }
            }
          },
          type: 'raw'
        });

        // Send projectRoot to main process. main process will close this project
        // when XDE is closed.
        _electron.ipcRenderer.send('project-opened', projectRoot);

        const projectJson = yield _xdl.Exp.expInfoSafeAsync(projectRoot);

        _this.setState({
          projectSettings,
          projectRoot,
          projectJson,
          isProjectRunning: false,
          isLoading: true
        }, (0, _asyncToGenerator3.default)(function* () {
          try {
            let expJson = yield _xdl.Project.startAsync(projectRoot);
            _this._logInfo(PROJECT_OPENED_MESSAGE);

            let computedUrl = yield _this._computeUrlAsync(projectRoot);
            let exponentSdkStatus = yield _xdl.Doctor.getExponentSdkStatus(projectRoot);
            _this.setState({
              computedUrl,
              isProjectRunning: true,
              expJson,
              exponentSdkStatus,
              isLoading: false
            });
          } catch (err) {
            _this._logError(err.message);
          }
        }));

        return true;
      });

      return function (_x5) {
        return _ref12.apply(this, arguments);
      };
    })();

    this._stopProjectAsync = (() => {
      var _ref14 = (0, _asyncToGenerator3.default)(function* (projectRoot) {
        if (!_this.state.projectRoot) {
          return false;
        }

        _this._currentOpenProjectXDEId++;

        // Send projectRoot to main process.
        _electron.ipcRenderer.send('project-closed', projectRoot);

        try {
          yield _xdl.Project.stopAsync(projectRoot);
          _this._logInfo('Project closed.');
          _this.setState({
            projectSettings: null,
            projectRoot: null,
            projectJson: null,
            computedUrl: null,
            isProjectRunning: false,
            expJson: null,
            logs: [],
            connectedDevices: {},
            focusedConnectedDeviceId: null
          });
          _this._resetLocalProperties();

          return true;
        } catch (err) {
          _this._logError(err.message);

          return false;
        }
      });

      return function (_x6) {
        return _ref14.apply(this, arguments);
      };
    })();

    this.state = {
      logs: [],
      connectedDevices: {}, // mapping of device id -> {name, logs: array of logs}
      focusedConnectedDeviceId: null,
      isProjectRunning: false,
      projectRoot: null,
      projectJson: null,
      recentExps: [],
      user: null,
      projectSettings: null,
      notification: null,
      computedUrl: null,
      openPopover: null, // The currently open popover
      isLoading: false,
      openModal: null,
      expJson: null,
      exponentSdkStatus: _xdl.Doctor.EXPONENT_SDK_INSTALLED_AND_IMPORTED,
      tabsVisible: TAB_BOTH_VISIBLE
    };

    this._resetLocalProperties();
    this._notificationTimeout = null;
    this._currentOpenProjectXDEId = 0; // used to avoid logging old projects
    global._App = this;

    if (props.segment && !process.env.XDE_NPM_START) {
      _xdl.Analytics.setSegmentWebInstance(props.segment);
    }

    this._setVersionAsync();
  }

  _resetLocalProperties() {
    this._startTime = new Date();
    this._logsToAdd = [];
    this._deviceLogsToAdd = [];
    this._deviceIdToName = {};
  }

  _renderTabs() {
    let tabsVisible = this.state.tabsVisible;


    return _react2.default.createElement(
      'div',
      { className: (0, _noImportant.css)(styles.tabsContainer) },
      tabsVisible !== TAB_RIGHT_VISIBLE && this._renderPackagerConsole(),
      tabsVisible === TAB_BOTH_VISIBLE && _react2.default.createElement('div', { className: (0, _noImportant.css)(styles.verticalSeparator) }),
      tabsVisible !== TAB_LEFT_VISIBLE && this._renderDeviceLogs()
    );
  }

  _renderPackagerConsole() {
    let bottomBarRightContent = this.state.tabsVisible === TAB_LEFT_VISIBLE ? this._renderTabsVisibleControl() : null;
    return _react2.default.createElement(
      'div',
      { className: (0, _noImportant.css)(styles.tabContainer) },
      _react2.default.createElement(_ConsoleLog2.default, {
        logs: this.state.logs,
        isLoading: this.state.isLoading,
        onClickClearLogs: this._onClickClearLogs,
        bottomBarRightContent: bottomBarRightContent
      })
    );
  }

  _renderPopoverDeviceLogs() {
    if (this.state.openPopover !== _Constants.PopoverEnum.DEVICE_LOGS) {
      return null;
    }

    let menuItems = [];
    _lodash2.default.forEach(this.state.connectedDevices, (device, deviceId) => {
      const isSelected = this.state.focusedConnectedDeviceId === deviceId;

      /* eslint-disable react/jsx-no-bind */
      menuItems.push(_react2.default.createElement(_MenuItem2.default, {
        label: device.name,
        key: deviceId,
        checkState: isSelected ? 'checked' : 'unchecked',
        onClick: () => this._setSelectedDevice(deviceId)
      }));
      /* eslint-enable react/jsx-no-bind */
    });

    return _react2.default.createElement(
      'div',
      null,
      menuItems
    );
  }

  _renderProjectList() {
    return _react2.default.createElement(_ProjectList2.default, { projects: this.state.recentExps, onSelect: this._runProject });
  }

  _renderUrlInput() {
    return _react2.default.createElement(
      'div',
      { className: (0, _noImportant.css)(styles.urlInputContainer) },
      _react2.default.createElement(
        _Popover2.default,
        { body: this._renderPopoverOptions(), arrowOffset: 16 },
        _react2.default.createElement('img', {
          src: './gear.svg',
          className: (0, _noImportant.css)(styles.iconWithMargin, styles.optionsIcon),
          onClick: this._toggleOptionsPopover
        })
      ),
      _react2.default.createElement('input', {
        ref: r => {
          this._urlInput = r;
        },
        className: (0, _noImportant.css)(styles.urlInput),
        value: this.state.computedUrl || '',
        placeholder: 'Waiting for packager and tunnel to start...',
        onClick: this._urlInputSelect
      }),
      _react2.default.createElement('img', {
        src: './IconArrowUpRight.png',
        className: (0, _noImportant.css)(styles.urlInputCopyIcon),
        onClick: this._urlInputCopy
      })
    );
  }

  _renderPopoverOptions() {
    if (this.state.openPopover !== _Constants.PopoverEnum.OPTIONS) {
      return null;
    }

    const hostMenuItems = ['Tunnel', 'LAN', 'localhost'].map(label => {
      const option = label.toLowerCase();
      const checkState = this.state.projectSettings.hostType === option ? 'checked' : 'unchecked';

      /* eslint-disable react/jsx-no-bind */
      return _react2.default.createElement(_MenuItem2.default, {
        label: label,
        key: option,
        checkState: checkState,
        onClick: () => this._setProjectSettingAsync({ hostType: option })
      });
      /* eslint-enable react/jsx-no-bind */
    });

    const protocolMenuItems = ['exp', 'http', 'redirect'].map(option => {
      const checkState = this.state.projectSettings.urlType === option ? 'checked' : 'unchecked';

      /* eslint-disable react/jsx-no-bind */
      return _react2.default.createElement(_MenuItem2.default, { label: option, key: option, checkState: checkState,
        onClick: () => this._setProjectSettingAsync({ urlType: option })
      });
      /* eslint-enable react/jsx-no-bind */
    });

    const otherMenuItems = [{
      label: 'Development Mode',
      option: 'dev'
    }, {
      label: 'Minify',
      option: 'minify'
    }].map((_ref15) => {
      let label = _ref15.label;
      let option = _ref15.option;

      const isEnabled = this.state.projectSettings[option];

      /* eslint-disable react/jsx-no-bind */
      return _react2.default.createElement(_MenuItem2.default, { label: label, key: option,
        checkState: isEnabled ? 'checked' : 'unchecked',
        onClick: () => this._setProjectSettingAsync({ [option]: !isEnabled })
      });
      /* eslint-enable react/jsx-no-bind */
    });

    // Just for aesthetics, make top-level MenuItems all "unchecked" (so the
    // beginning of the text lines up)
    return _react2.default.createElement(
      'div',
      null,
      _react2.default.createElement(
        _MenuItem2.default,
        { label: 'Host', checkState: 'unchecked' },
        _react2.default.createElement(
          'div',
          { style: _Styles2.default.hoverBox },
          hostMenuItems
        )
      ),
      _react2.default.createElement(
        _MenuItem2.default,
        { label: 'Protocol', checkState: 'unchecked' },
        _react2.default.createElement(
          'div',
          { style: _Styles2.default.hoverBox },
          protocolMenuItems
        )
      ),
      otherMenuItems
    );
  }

  _renderModal() {
    if (!this.state.openModal) {
      return null;
    }

    switch (this.state.openModal) {
      case _Constants.ModalEnum.NEW_PROJECT:
        return _react2.default.createElement(_NewProjectModal2.default, {
          onClose: this._closeModal,
          onSelectProject: this._startProjectAsync
        });
    }
  }

  render() {
    /* eslint-disable react/jsx-no-bind */
    return _react2.default.createElement(
      'div',
      { onClick: this._closePopover },
      _react2.default.createElement(
        _LoginPage2.default,
        {
          loggedInAs: this.state.user,
          onLogin: user => {
            this.setState({ user });
          } },
        _react2.default.createElement(
          'div',
          { className: (0, _noImportant.css)(styles.container) },
          _react2.default.createElement(_NewVersionAvailable2.default, null),
          _react2.default.createElement(
            'div',
            null,
            this.state.notification && _react2.default.createElement(_Notification2.default, this.state.notification),
            _react2.default.createElement(
              'div',
              { className: (0, _noImportant.css)(styles.topSection) },
              _react2.default.createElement(_ToolBar2.default, {
                isProjectOpen: !!this.state.projectRoot && !!this.state.projectSettings,
                isProjectRunning: this.state.isProjectRunning,
                onAppendErrors: this._logError,
                onAppendLogs: this._logInfo,
                onLogOut: this._logOutAsync,
                onNewProjectClick: this._newClickedAsync,
                onOpenProjectClick: this._openClickedAsync,
                onCloseProjectClick: this._closeClickedAsync,
                onPublishClick: this._publishClickedAsync,
                onRestartClick: this._restartClickedAsync,
                onSendLinkClick: this._sendClickedAsync,
                onDocsClicked: this._docsClicked,
                onJoinUsOnSlackClicked: this._joinUsOnSlackClicked,
                onChatWithUsOnIntercomClicked: this._chatWithUsOnIntercomClicked,
                onSendDiagnosticsReportClicked: this._sendDiagnosticsReportClicked,
                onClearXDECacheClicked: this._clearXDECacheClicked,
                onTogglePopover: this._onTogglePopover,
                openPopover: this.state.openPopover,
                projectJson: this.state.projectJson,
                projectRoot: this.state.projectRoot,
                projectSettings: this.state.projectSettings,
                sendTo: this.state.sendTo,
                userName: this.state.user && this.state.user.username
              }),
              this.state.projectSettings && this._renderUrlInput()
            )
          ),
          this.state.projectRoot ? this._renderTabs() : this._renderProjectList()
        )
      ),
      !!this.state.openModal && _react2.default.createElement(
        'div',
        { className: (0, _noImportant.css)(styles.modalOverlay) },
        _react2.default.createElement(
          'div',
          { className: (0, _noImportant.css)(styles.modalContent) },
          this._renderModal()
        )
      )
    );
    /* eslint-enable react/jsx-no-bind */
  }

  _versionStringAsync() {
    return (0, _asyncToGenerator3.default)(function* () {
      let pkgJsonFile = new _jsonFile2.default(_path2.default.join(__dirname, '../../package.json'));
      let versionString = yield pkgJsonFile.getAsync('version');
      return versionString;
    })();
  }

  _setVersionAsync() {
    var _this2 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      let version = yield _this2._versionStringAsync();
      _xdl.Analytics.setVersionName(version);
      _xdl.Intercom.setVersionName(version);
    })();
  }

  _showNotification(type, message, options, onClick) {
    // If there is already a notification showing, cancel its timeout.
    if (this._notificationTimeout) {
      clearTimeout(this._notificationTimeout);
    }

    let clearnNotificationOnClick = onClick ? () => {
      this._clearNotification();
      onClick();
    } : null;

    // Show a notification, then hide it after a while.
    this.setState({ notification: {
        type,
        message,
        onClick: clearnNotificationOnClick
      } });

    if (!options || !options.indefinite) {
      this._notificationTimeout = setTimeout(() => {
        this._notificationTimeout = null;
        this.setState({ notification: null });
      }, NOTIFICATION_TIMEOUT_MS);
    }
  }

  _clearNotification() {
    if (this._notificationTimeout) {
      clearTimeout(this._notificationTimeout);
    }

    this._notificationTimeout = null;
    this.setState({ notification: null });
  }

  // If multiple devices with the same name are connected, add ' - 1', ' - 2' to their names.


  componentDidMount() {
    _xdl.UserSettings.getAsync('sendTo').then(sendTo => {
      this.setState({ sendTo });
    }, err => {
      // Probably means that there's no saved value here; not a huge deal
      // console.error("Error getting sendTo:", err);
    });

    _xdl.Exp.recentValidExpsAsync().then(recentExps => {
      this.setState({ recentExps });
    }, err => {
      console.error("Couldn't get list of recent Exps :(", err);
    });

    // this._versionStringAsync().then((vs) => {
    //   this.setState({versionString: vs});
    // }, (err) => {
    //   console.error("Couldn't get version string :(", err);
    // });

    let args = [];
    if (process.env.XDE_CMD_LINE_ARGS) {
      try {
        args = JSON.parse(process.env.XDE_CMD_LINE_ARGS);
      } catch (e) {
        console.error(`Malformed XDE_CMD_LINE_ARGS: ${ process.env.XDE_CMD_LINE_ARGS }`);
      }
      if (args.length === 1) {
        let openPath = _path2.default.resolve(process.env.XDE_CMD_LINE_CWD, args[0]);

        console.log(`Open project at ${ openPath }`);

        this._startProjectAsync(args[0]);
      }
    }

    this._registerLogs();

    _electron.ipcRenderer.on('menu-item-clicked', (() => {
      var _ref16 = (0, _asyncToGenerator3.default)(function* (event, item) {
        switch (item) {
          case 'install-shell-commands':
            yield _xdl.Binaries.installShellCommandsAsync();
            break;
          case 'install-android-app':
            yield _xdl.Android.upgradeExponentAsync();
            break;
          case 'install-ios-simulator-app':
            yield _xdl.Simulator.upgradeExponentAsync();
            break;
        }
      });

      return function (_x7, _x8) {
        return _ref16.apply(this, arguments);
      };
    })());
  }

  componentWillUnmount() {
    if (this._notificationTimeout) {
      clearTimeout(this._notificationTimeout);
    }
  }

  _computeUrlAsync(root) {
    return (0, _asyncToGenerator3.default)(function* () {
      if (!root) {
        return null;
      }

      return _xdl.UrlUtils.constructManifestUrlAsync(root);
    })();
  }

  _registerLogs() {
    _xdl.Logger.notifications.addStream({
      stream: {
        write: chunk => {
          switch (chunk.code) {
            case _xdl.NotificationCode.OLD_IOS_APP_VERSION:
              this._showNotification('warning', 'Exponent app on iOS simulator is out of date. Click to upgrade.', {}, (0, _asyncToGenerator3.default)(function* () {
                yield _xdl.Simulator.upgradeExponentAsync();
              }));
              return;
            case _xdl.NotificationCode.OLD_ANDROID_APP_VERSION:
              this._showNotification('warning', 'Exponent app on Android device is out of date. Click to upgrade.', {}, (0, _asyncToGenerator3.default)(function* () {
                yield _xdl.Android.upgradeExponentAsync();
              }));
              return;
            case _xdl.NotificationCode.START_LOADING:
              this.setState({
                isLoading: true
              });
              return;
            case _xdl.NotificationCode.STOP_LOADING:
              this.setState({
                isLoading: false
              });
              return;
          }

          let notificationOptions = {
            indefinite: !!chunk.indefinite
          };
          if (chunk.level <= _bunyan2.default.INFO) {
            this._showNotification('info', chunk.msg, notificationOptions);
          } else {
            this._showNotification('warning', chunk.msg, notificationOptions);
          }
        }
      },
      type: 'raw'
    });

    _xdl.Logger.global.addStream({
      stream: {
        write: chunk => {
          this._appendLogChunk(chunk);
        }
      },
      type: 'raw'
    });
  }
};
App.propTypes = {
  segment: _react.PropTypes.array
};


let styles = _noImportant.StyleSheet.create({
  container: {
    display: 'flex',
    flexDirection: 'column',
    height: '100vh',
    backgroundImage: _xdl.Env.isStaging() ? 'url("./staging.jpg")' : null
  },

  topSection: {
    margin: _StyleConstants2.default.gutterLg
  },

  urlInputContainer: {
    display: 'flex',
    alignItems: 'center',
    marginTop: _StyleConstants2.default.gutterLg,
    position: 'relative' },

  urlInput: (0, _extends3.default)({}, _Styles2.default.input, {
    flex: 1,
    paddingLeft: OPTIONS_ICON_SIZE + _StyleConstants2.default.gutterMd * 2 - _StyleConstants2.default.gutterSm
  }),

  urlInputCopyIcon: {
    cursor: 'pointer',
    padding: _StyleConstants2.default.gutterMd, // Pad clickable area

    position: 'absolute',
    right: 0,
    top: '50%',
    height: _StyleConstants2.default.gutterMd * 2 + 10,
    marginTop: -(_StyleConstants2.default.gutterMd * 2 + 10) / 2
  },

  iconWithMargin: {
    cursor: 'pointer',
    marginTop: _StyleConstants2.default.gutterSm,
    marginBottom: _StyleConstants2.default.gutterSm
  },

  optionsIcon: {
    height: OPTIONS_ICON_SIZE,
    marginLeft: _StyleConstants2.default.gutterMd,
    marginRight: -(_StyleConstants2.default.gutterMd + OPTIONS_ICON_SIZE)
  },

  deviceSelectIcon: {
    height: DEVICES_ICON_SIZE,
    marginLeft: _StyleConstants2.default.gutterMd,
    marginRight: -(_StyleConstants2.default.gutterMd + DEVICES_ICON_SIZE)
  },

  modalOverlay: {
    position: 'fixed',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: 'rgba(0, 0, 0, 0.8)',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center'
  },

  modalContent: {
    background: _StyleConstants2.default.colorBackground,
    overflow: 'auto',
    borderRadius: '2px',
    outline: 'none'
  },

  tabsContainer: {
    display: 'flex',
    flexDirection: 'row',
    height: '100%'
  },

  verticalSeparator: {
    width: 2,
    display: 'flex',
    backgroundColor: _StyleConstants2.default.colorBackground
  },

  tabContainer: {
    flex: '1',
    display: 'flex',
    flexDirection: 'column',
    height: '100%'
  },

  deviceSelectText: {
    fontSize: _StyleConstants2.default.fontSizeSm,
    color: _StyleConstants2.default.colorText,
    paddingLeft: DEVICES_ICON_SIZE + _StyleConstants2.default.gutterMd * 2 - _StyleConstants2.default.gutterSm,
    marginVertical: _StyleConstants2.default.gutterSm
  },

  tabsVisibleControl: {
    display: 'inline-flex',
    justifyContent: 'space-between',
    width: 24,
    marginRight: _StyleConstants2.default.gutterLg
  },

  tabVisibleIcon: {
    height: DEVICES_ICON_SIZE,
    marginLeft: _StyleConstants2.default.gutterMd,
    marginRight: -(_StyleConstants2.default.gutterMd + DEVICES_ICON_SIZE)
  }
});

global.cl = function (a, b, c) {
  console.log(a, b, c);
};

global.ce = function (a, b, c) {
  console.error(a, b, c);
};

module.exports = App;
//# sourceMappingURL=../__sourcemaps__/ui/App.js.map
