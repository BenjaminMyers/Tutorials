/**
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
'use strict';

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _setImmediate2 = require('babel-runtime/core-js/set-immediate');

var _setImmediate3 = _interopRequireDefault(_setImmediate2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var fs = jest.genMockFromModule('fs');
var noop = function noop() {};

function asyncCallback(cb) {
  return function () {
    var _this = this,
        _arguments = arguments;

    (0, _setImmediate3.default)(function () {
      return cb.apply(_this, _arguments);
    });
  };
}

var mtime = {
  getTime: function getTime() {
    return Math.ceil(Math.random() * 10000000);
  }
};

fs.realpath.mockImpl(function (filepath, callback) {
  callback = asyncCallback(callback);
  var node = void 0;
  try {
    node = getToNode(filepath);
  } catch (e) {
    return callback(e);
  }
  if (node && (typeof node === 'undefined' ? 'undefined' : (0, _typeof3.default)(node)) === 'object' && node.SYMLINK != null) {
    return callback(null, node.SYMLINK);
  }
  callback(null, filepath);
});

fs.readdirSync.mockImpl(function (filepath) {
  return (0, _keys2.default)(getToNode(filepath));
});

fs.readdir.mockImpl(function (filepath, callback) {
  callback = asyncCallback(callback);
  var node = void 0;
  try {
    node = getToNode(filepath);
    if (node && (typeof node === 'undefined' ? 'undefined' : (0, _typeof3.default)(node)) === 'object' && node.SYMLINK != null) {
      node = getToNode(node.SYMLINK);
    }
  } catch (e) {
    return callback(e);
  }

  if (!(node && (typeof node === 'undefined' ? 'undefined' : (0, _typeof3.default)(node)) === 'object' && node.SYMLINK == null)) {
    return callback(new Error(filepath + ' is not a directory.'));
  }

  callback(null, (0, _keys2.default)(node));
});

fs.readFile.mockImpl(function (filepath, encoding, callback) {
  callback = asyncCallback(callback);
  if (arguments.length === 2) {
    callback = encoding;
    encoding = null;
  }

  var node = void 0;
  try {
    node = getToNode(filepath);
    // dir check
    if (node && (typeof node === 'undefined' ? 'undefined' : (0, _typeof3.default)(node)) === 'object' && node.SYMLINK == null) {
      callback(new Error('Error readFile a dir: ' + filepath));
    }
    return callback(null, node);
  } catch (e) {
    return callback(e);
  }
});

fs.writeFile.mockImpl(function (filepath, data, encoding, callback) {
  callback = asyncCallback(callback);
  if (arguments.length === 2) {
    callback = encoding;
    encoding = null;
  }

  try {
    writeNode(filepath, data);
    return callback(null);
  } catch (e) {
    return callback(e);
  }
});

fs.mkdir.mockImpl(function (filepath, mode, callback) {
  callback = asyncCallback(callback);
  if (arguments.length === 2) {
    callback = mode;
    mode = null;
  }

  try {
    writeNode(filepath, null, true);
    return callback(null);
  } catch (e) {
    return callback(e);
  }
});

fs.mkdirSync.mockImpl(function (filepath, mode) {
  writeNode(filepath, null, true);
});

fs.stat.mockImpl(function (filepath, callback) {
  callback = asyncCallback(callback);
  var node = void 0;
  try {
    node = getToNode(filepath);
  } catch (e) {
    callback(e);
    return;
  }

  if (node.SYMLINK) {
    fs.stat(node.SYMLINK, callback);
    return;
  }

  if (node && (typeof node === 'undefined' ? 'undefined' : (0, _typeof3.default)(node)) === 'object') {
    callback(null, {
      isDirectory: function isDirectory() {
        return true;
      },
      isSymbolicLink: function isSymbolicLink() {
        return false;
      },
      mtime: mtime
    });
  } else {
    callback(null, {
      isDirectory: function isDirectory() {
        return false;
      },
      isSymbolicLink: function isSymbolicLink() {
        return false;
      },
      mtime: mtime
    });
  }
});

fs.statSync.mockImpl(function (filepath) {
  var node = getToNode(filepath);

  if (node.SYMLINK) {
    return fs.statSync(node.SYMLINK);
  }

  return {
    isDirectory: function isDirectory() {
      return node && (typeof node === 'undefined' ? 'undefined' : (0, _typeof3.default)(node)) === 'object';
    },
    isSymbolicLink: function isSymbolicLink() {
      return false;
    },
    mtime: mtime
  };
});

fs.lstatSync.mockImpl(function (filepath) {
  var node = getToNode(filepath);

  if (node.SYMLINK) {
    return {
      isDirectory: function isDirectory() {
        return false;
      },
      isSymbolicLink: function isSymbolicLink() {
        return true;
      },
      mtime: mtime
    };
  }

  return {
    isDirectory: function isDirectory() {
      return node && (typeof node === 'undefined' ? 'undefined' : (0, _typeof3.default)(node)) === 'object';
    },
    isSymbolicLink: function isSymbolicLink() {
      return false;
    },
    mtime: mtime
  };
});

fs.open.mockImpl(function (path) {
  var callback = arguments[arguments.length - 1] || noop;
  var data = void 0,
      error = void 0,
      fd = void 0;
  try {
    data = getToNode(path);
  } catch (e) {
    error = e;
  }

  if (error || data == null) {
    error = Error('ENOENT: no such file or directory, open ' + path);
  }
  if (data != null) {
    /* global Buffer: true */
    fd = { buffer: new Buffer(data, 'utf8'), position: 0 };
  }

  callback(error, fd);
});

fs.read.mockImpl(function (fd, buffer, writeOffset, length, position) {
  var callback = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : noop;

  var bytesWritten = void 0;
  try {
    if (position == null || position < 0) {
      position = fd.position;
    }
    bytesWritten = fd.buffer.copy(buffer, writeOffset, position, position + length);
    fd.position = position + bytesWritten;
  } catch (e) {
    callback(Error('invalid argument'));
    return;
  }
  callback(null, bytesWritten, buffer);
});

fs.close.mockImpl(function (fd) {
  var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;

  try {
    fd.buffer = fs.position = undefined;
  } catch (e) {
    callback(Error('invalid argument'));
    return;
  }
  callback(null);
});

var filesystem = {
  // 'home': {},
};

fs.__setMockFilesystem = function (object) {
  return filesystem = object;
};
fs.__getMockFilesystem = function () {
  return filesystem;
};
fs.__addLoggedInUser = function () {
  filesystem['home']['.exponent']['exponent.json'] = (0, _stringify2.default)({
    'accessToken': 'c-mD8xpssIS9mhIhNW01ZegQ',
    'type': 'client',
    'username': 'jesse'
  });
};

function getToNode(filepath) {
  // Ignore the drive for Windows paths.
  if (filepath.match(/^[a-zA-Z]:\\/)) {
    filepath = filepath.substring(2);
  }

  var parts = filepath.split(/[\/\\]/);
  if (parts[0] !== '') {
    throw new Error('Make sure all paths are absolute.');
  }
  var node = filesystem;
  parts.slice(1).forEach(function (part) {
    if (node && node.SYMLINK) {
      node = getToNode(node.SYMLINK);
    }
    node = node[part];
  });

  if (!node) {
    throw new Error('No file exists at: ' + filepath);
  }

  return node;
}

function writeNode(filepath, data, mkdir) {
  // Ignore the drive for Windows paths.
  if (filepath.match(/^[a-zA-Z]:\\/)) {
    filepath = filepath.substring(2);
  }

  var parts = filepath.split(/[\/\\]/);
  if (parts[0] !== '') {
    throw new Error('Make sure all paths are absolute.');
  }
  var node = filesystem;
  parts.slice(1, parts.length - 1).forEach(function (part) {
    if (node && node.SYMLINK) {
      node = getToNode(node.SYMLINK);
    }
    node = node[part];

    if (!node) {
      var err = new Error('Does not exist.');
      err.code = 'ENOENT';
      throw err;
    }
  });

  if (mkdir) {
    if (node[parts[parts.length - 1]]) {
      throw new Error('Node already exists at: ' + filepath);
    } else {
      node[parts[parts.length - 1]] = {};
    }
  } else {
    if ((typeof node === 'undefined' ? 'undefined' : (0, _typeof3.default)(node)) !== 'object' || node.SYMLINK) {
      throw new Error('Error not a dir: ' + filepath);
    }

    node[parts[parts.length - 1]] = data;
  }
}

module.exports = fs;
//# sourceMappingURL=../__sourcemaps__/__mocks__/graceful-fs.js.map
